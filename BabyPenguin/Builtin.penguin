namespace __builtin {
    extern fun print(val text : string);
    extern fun println(val text : string);
    fun hello_world() {
        println("hello world!");
    }

    enum Option<T> {
        some: T;
        none;
    
        fun is_some(val this: Option<T>) -> bool {
            return this is Option<T>.some;
        }

        fun is_none(val this: Option<T>) -> bool {
            return this is Option<T>.none;
        }
    
        fun value_or(val this: Option<T>, val default_val: T) -> T {
            if (this is Option<T>.some) {
                return this.some;
            } else {
                return default_val;
            }
        }

        impl __builtin.ICopy<Option<T>> where T: ICopy<T>;
    }

    interface ICopy<T> {
        extern fun copy(val this: T) -> T;
    }
        
    impl __builtin.ICopy<i64> for i64;
    impl __builtin.ICopy<u64> for u64;
    impl __builtin.ICopy<i32> for i32;
    impl __builtin.ICopy<u32> for u32;
    impl __builtin.ICopy<i16> for i16;
    impl __builtin.ICopy<u16> for u16;
    impl __builtin.ICopy<i8> for i8;
    impl __builtin.ICopy<u8> for u8;
    impl __builtin.ICopy<bool> for bool;
    impl __builtin.ICopy<char> for char;
    impl __builtin.ICopy<string> for string;
    impl __builtin.ICopy<float> for float;
    impl __builtin.ICopy<double> for double;

        enum Result<T, E> {
        ok: T;
        error: E;
    
        fun is_ok(val this: Result<T, E>) -> bool {
            return this is Result<T, E>.ok;
        }

        fun is_error(val this: Result<T, E>) -> bool {
            return this is Result<T, E>.error;
        }
    
        fun value_or(val this: Result<T, E>, val default_val: T) -> T {
            if (this is Result<T, E>.ok) {
                return this.ok;
            } else {
                return default_val;
            }
        }

        impl __builtin.ICopy<Result<T, E>> where T: ICopy<T>, E: ICopy<E>;
    }

    interface IIterator<T> {
        fun next(var this: IIterator<T>) -> Option<T>;
    }

    interface IIterable<T> {
        fun iter(var this: IIterable<T>) -> IIterator<T>;
    }

    class RangeIterator {
        val start: i64;
        val end: i64;
        var current: i64;

        fun new(var this: RangeIterator, val start: i64, val end: i64) {
            this.start = start;
            this.end = end;
            this.current = start;
        }

        impl IIterator<i64> {
            fun next(var this: IIterator<i64>) -> Option<i64> {
                var self : RangeIterator = this as RangeIterator;
                if (self.current < self.end) {
                    val res : Option<i64> =new Option<i64>.some(self.current);
                    self.current += 1;
                    return res;
                } else {
                    return new Option<i64>.none();
                }
            }
        }
    }

    fun range(val start: i64, val end: i64) -> IIterator<i64> {
        return new RangeIterator(start, end) as IIterator<i64>;
    }

    class AtomicI64 {
        var value: i64;
        fun new(var this: AtomicI64, val value: i64) {
            this.value = value;
        }
        fun load(val this: AtomicI64) -> i64 {
            return this.value;
        }
        fun store(var this: AtomicI64, val value: i64) {
            this.value = value;
        }
        extern fun swap(var this: AtomicI64, val value: i64) -> i64;
        extern fun compare_exchange(var this: AtomicI64, var current_val: i64, val new_val: i64) -> i64;
        extern fun fetch_add(var this: AtomicI64, val value: i64) -> i64;
    }

    class List<T> {
        var __impl: u64;
        extern fun new(var this: List<T>);
        extern fun at(val this: List<T>, val index: u64) -> Option<T>;
        extern fun push(var this: List<T>, val value: T);
        extern fun pop(var this: List<T>) -> Option<T>;
        extern fun size(val this: List<T>) -> u64;

        impl IIterable<T> {
            fun iter(var this: IIterable<T>) -> IIterator<T> {
                return new ListIterator<T>(this as List<T>) as IIterator<T>;
            }
        }
    }

    class ListIterator<T> {
        var list : List<T>;
        var current: u64;

        fun new(var this: ListIterator<T>, var list: List<T>) {
            this.list = list;
            this.current = 0;
        }

        impl IIterator<T> {
            fun next(var this: IIterator<T>) -> Option<T> {
                var self : ListIterator<T> = this as ListIterator<T>;
                var res : Option<T> = self.list.at(self.current);
                self.current += 1;
                return res;
            }
        }
    }

    class Queue<T> {
        var __impl: u64;
        extern fun new(var this: Queue<T>);
        extern fun enqueue(var this: Queue<T>, val value: T);
        extern fun dequeue(var this: Queue<T>) -> Option<T>;
        extern fun peek(var this: Queue<T>) -> Option<T>;
        extern fun size(val this: Queue<T>) -> u64;
    }

    enum RoutineState {
        pending;
        running;
        ready;
        finished;

        fun from_i64(val v: i64) -> RoutineState {
            if (v == 0) {
                return new RoutineState.pending();
            } else if (v == 1) {
                return new RoutineState.running();
            } else if (v == 2) {
                return new RoutineState.ready();
            } else {
                return new RoutineState.finished();
            }
        }

        fun from_atomic(val a: AtomicI64) -> RoutineState {
            val v : i64 = a.load();
            return RoutineState.from_i64(v);
        }

        fun to_i64(val v: RoutineState) -> i64 {
            if (v is RoutineState.pending) {
                return 0;
            } else if (v is RoutineState.running) {
                return 1;
            } else if (v is RoutineState.ready) {
                return 2;
            } else {
                return 3;
            }
        }

        fun switch(var v: AtomicI64, val from: RoutineState, val to: RoutineState) -> bool {
            val from_i64 : i64 = from.to_i64();
            val to_i64 : i64 = to.to_i64();
            val res : i64 = v.compare_exchange(from_i64, to_i64);
            return res == from_i64;
        }
    }

    enum FutureState<T> {
        not_ready;
        ready: T;
        finished;
        ready_finished: T;
    }

    interface IFutureBase {
        fun routine_state(val this: IFutureBase) -> RoutineState;
        fun start(var this: IFutureBase) -> bool;
    }

    interface IFuture<T> {
        impl IFutureBase;
        fun poll(val this: IFuture<T>) -> FutureState<T>;
        fun set_result(var this: IFuture<T>, val result: Option<T>, val is_finished: bool) -> bool;
    }

    class RoutineContext {
        var target: fun;
        var frame: i64;

        extern fun new(var this: RoutineContext, val symbol: string);
        extern fun call(var this: RoutineContext) -> i64;
    }

    class Scheduler {
        var pending_jobs : Queue<IFutureBase> = new Queue<IFutureBase>();
        var ready_jobs : Queue<IFutureBase> = new Queue<IFutureBase>();

        fun entry(var this: Scheduler) {
            while (true) {
                var job_opt : Option<IFutureBase> = this.pending_jobs.dequeue();
                if (job_opt.is_some()) {
                    var job : IFutureBase = job_opt.some;
                    val result: bool = job.start();
                    if (!result) {
                        // job is in invalid state, skip it for now
                        println("Scheduler: job in '" + (job.routine_state() as string) + "' state, failed to run");
                    }
                    else {
                        val state : RoutineState = job.routine_state();
                        if (state is RoutineState.pending) {
                            this.pending_jobs.enqueue(job);
                        } else if (state is RoutineState.ready) {
                            this.ready_jobs.enqueue(job);
                        } else if (state is RoutineState.finished) {
                            // job is finished, remove it from queue
                        }
                    }
                } else {
                    break;
                }
            }
        }

        fun current() -> Scheduler {
            return _main_scheduler;
        }
    }

    var _main_scheduler : Scheduler = new Scheduler();

    class SimpleRoutine {
        var state: AtomicI64 = new AtomicI64(0);
        var context: RoutineContext;

        fun new(var this: SimpleRoutine, val context_symbol: string) {
            this.context = new RoutineContext(context_symbol);
        }

        impl IFutureBase {
            fun routine_state(val this: IFutureBase) -> RoutineState {
                var self: SimpleRoutine = this as SimpleRoutine;
                return RoutineState.from_atomic(self.state);
            }

            fun start(val this: IFutureBase) -> bool {
                var self: SimpleRoutine = this as SimpleRoutine;
                val res : bool = RoutineState.switch(self.state, new RoutineState.pending(), new RoutineState.running());
                if (!res) 
                    return false;
                val return_state : i64 = self.context.call();

                if (return_state == 0) {
                    // blocked, put back as pending
                    RoutineState.switch(self.state, new RoutineState.running(), new RoutineState.pending());
                } else if (return_state == 1) {
                    // yield not finished
                    RoutineState.switch(self.state, new RoutineState.running(), new RoutineState.pending());
                } else if (return_state == 2 || return_state == 3) {
                    // yield finished & finished
                    RoutineState.switch(self.state, new RoutineState.running(), new RoutineState.finished());
                }

                return true;
            }
        }

        impl IFuture<void> {
            fun poll(val this: IFuture<void>) -> FutureState<void> {
                var self: SimpleRoutine = this as SimpleRoutine;
                val state_val: i64 = self.state.load();
                
                if (state_val == 2) {
                    return new FutureState<void>.ready(void);
                } else if (state_val == 3) {
                    return new FutureState<void>.finished();
                }
                else {
                    return new FutureState<void>.not_ready();
                }
            }

            fun set_result(var this: IFuture<void>, val result: Option<void>, val is_finished: bool) -> bool {
                var self: SimpleRoutine = this as SimpleRoutine;
                return RoutineState.switch(self.state, new RoutineState.running(), new RoutineState.finished());
            }
        }
    }
}