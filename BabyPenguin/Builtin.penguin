namespace __builtin {
    extern fun exit(code : i32);
    extern fun print(text : string);
    extern fun println(text : string);
    fun hello_world() {
        println("hello world!");
    }

    class Box<T> {
        value: T;
        fun new(mut this, value: T) {
            this.value = value;
        }
    }

    class __ExternImpl {}

    enum Option<T> {
        some: T;
        none;
    
        fun is_some(this) -> bool {
            return this is Option<T>.some;
        }

        fun is_none(this) -> bool {
            return this is Option<T>.none;
        }
    
        fun value_or(this, default_val: T) -> T {
            if (this is Option<T>.some) {
                return this.some;
            } else {
                return default_val;
            }
        }

        impl __builtin.ICopy<Option<T>> where T: ICopy<T>;
    }

    interface ICopy<T> {
        extern fun copy(this: T) -> T;
    }
        
    impl __builtin.ICopy<i64> for i64;
    impl __builtin.ICopy<u64> for u64;
    impl __builtin.ICopy<i32> for i32;
    impl __builtin.ICopy<u32> for u32;
    impl __builtin.ICopy<i16> for i16;
    impl __builtin.ICopy<u16> for u16;
    impl __builtin.ICopy<i8> for i8;
    impl __builtin.ICopy<u8> for u8;
    impl __builtin.ICopy<bool> for bool;
    impl __builtin.ICopy<char> for char;
    impl __builtin.ICopy<string> for string;
    impl __builtin.ICopy<float> for float;
    impl __builtin.ICopy<double> for double;

    enum Result<T, E> {
        ok: T;
        error: E;
    
        fun is_ok(this) -> bool {
            return this is Result<T, E>.ok;
        }

        fun is_error(this) -> bool {
            return this is Result<T, E>.error;
        }
    
        fun value_or(this, default_val: T) -> T {
            if (this is Result<T, E>.ok) {
                return this.ok;
            } else {
                return default_val;
            }
        }

        impl __builtin.ICopy<Result<T, E>> where T: ICopy<T>, E: ICopy<E>;
    }

    interface IIterator<T> {
        fun next(mut this) -> Option<T>;
    }

    interface IIterable<T> {
        fun iter(mut this) -> mut IIterator<T>;
    }

    class RangeIterator {
        start: mut i64;
        end: mut i64;
        current: mut i64;

        fun new(mut this, start: i64, end: i64) {
            this.start = start;
            this.end = end;
            this.current = start;
        }

        impl IIterator<i64> {
            fun next(this: mut IIterator<i64>) -> Option<i64> {
                let self : mut Self = this as mut Self;
                if (self.current < self.end) {
                    let res : mut Option<i64> = new Option<i64>.some(self.current);
                    self.current += 1;
                    return res;
                } else {
                    return new Option<i64>.none();
                }
            }
        }
    }

    fun range(start: i64, end: i64) -> mut IIterator<i64> {
        return new RangeIterator(start, end) as mut IIterator<i64>;
    }

    class AtomicI64 {
        value: mut i64;
        fun new(mut this, value: i64) {
            this.value = value;
        }
        fun load(this) -> i64 {
            return this.value;
        }
        fun store(mut this, value: i64) {
            this.value = value;
        }
        extern fun swap(mut this, value: i64) -> i64;
        extern fun compare_exchange(mut this, current_val: i64, new_val: i64) -> i64;
        extern fun fetch_add(mut this, value: i64) -> i64;
    }

    class List<T> {
        __impl: __ExternImpl = new __ExternImpl();
        extern fun new(mut this);
        extern fun at(this, index: u64) -> Option<T>;
        extern fun remove(mut this, index: u64);
        extern fun push(mut this, value: T);
        extern fun pop(mut this) -> Option<T>;
        extern fun size(this) -> u64;

        impl IIterable<T> {
            fun iter(this: mut IIterable<T>) -> mut IIterator<T> {
                return new ListIterator<T>(this as mut Self) as mut IIterator<T>;
            }
        }
    }

    class ListIterator<T> {
        list : !mut List<T>;
        current: mut u64;

        fun new(mut this, list: List<T>) {
            this.list = list;
            this.current = 0;
        }

        impl IIterator<T> {
            fun next(this: mut IIterator<T>) -> Option<T> {
                let self : mut ListIterator<T> = this as mut ListIterator<T>;
                let res : Option<T> = self.list.at(self.current);
                self.current += 1;
                return res;
            }
        }
    }

    class Queue<T> {
        __impl:  __ExternImpl = new __ExternImpl();
        extern fun new(mut this);
        extern fun enqueue(mut this, value: T);
        extern fun dequeue(mut this) -> Option<T>;
        extern fun peek(this) -> Option<T>;
        extern fun size(this) -> u64;
    }

    enum RoutineState {
        pending;
        running;
        ready;
        finished;
        ready_finished;

        fun from_i64(v: i64) -> mut RoutineState {
            if (v == 0) {
                return new RoutineState.pending();
            } else if (v == 1) {
                return new RoutineState.running();
            } else if (v == 2) {
                return new RoutineState.ready();
            } else if (v == 3) {
                return new RoutineState.finished();
            } else {
                return new RoutineState.ready_finished();
            }
        }

        fun from_atomic(a: AtomicI64) -> mut RoutineState {
            let v : mut i64 = a.load();
            return RoutineState.from_i64(v);
        }

        fun to_i64(this) -> i64 {
            if (this is RoutineState.pending) {
                return 0;
            } else if (this is RoutineState.running) {
                return 1;
            } else if (this is RoutineState.ready) {
                return 2;
            } else if (this is RoutineState.finished) {
                return 3;
            } else {
                return 4;
            }
        }

        fun switch(v: mut AtomicI64, from: RoutineState, to: RoutineState) -> bool {
            let from_i64 : mut i64 = from.to_i64();
            let to_i64 : mut i64 = to.to_i64();
            let res : mut i64 = v.compare_exchange(from_i64, to_i64);
            return res == from_i64;
        }
    }

    let __object_id : mut AtomicI64 = new AtomicI64(0);
    interface IObjectID {
        object_id : mut i64 = __object_id.fetch_add(1);
        fun equals(this, other: IObjectID) -> bool {
            return this.object_id == other.object_id;
        }
    }

    enum FutureState<T> {
        not_ready;
        ready: T;
        finished;
        ready_finished: T;
    }

    interface IFutureBase {
        fun routine_state(this) -> RoutineState;
        fun switch_state(mut this, from: RoutineState, to: RoutineState) -> bool;
        fun start(mut this) -> bool;
    }

    interface IFuture<T> {
        impl IFutureBase;
        fun poll(this) -> mut FutureState<T>;
        
        !async fun do_wait(mut this) -> T {
            let result: mut T;
            while(true) {
                wait;
                let state: mut FutureState<T> = this.poll();
                if (state is FutureState<T>.ready_finished) {
                    result = state.ready_finished;
                    break;
                }
                else if (state is FutureState<T>.ready) {
                    result = state.ready;
                    this.switch_state(new RoutineState.ready(), new RoutineState.pending());
                    _main_scheduler.pending_jobs.enqueue(this);
                } else if (state is FutureState<T>.finished) {
                    break;
                }
            }
            return result;
        }

        !async fun do_wait_any(this: mut IFuture<T>) -> Option<T> {
            while(true) {
                wait;
                let state: mut FutureState<T> = this.poll();
                if (state is FutureState<T>.ready_finished) {
                    this.switch_state(new RoutineState.ready_finished(), new RoutineState.finished());
                    return new Option<T>.some(state.ready_finished);
                }
                else if (state is FutureState<T>.ready) {
                    this.switch_state(new RoutineState.ready(), new RoutineState.pending());
                    _main_scheduler.pending_jobs.enqueue(this);
                    return new Option<T>.some(state.ready);
                } else if (state is FutureState<T>.finished) {
                    break;
                }
            }
            return new Option<T>.none();
        }
    }

    class Scheduler {
        pending_jobs : mut Queue<IFutureBase> = new Queue<IFutureBase>();

        fun entry(mut this) {
            while (true) {
                let job_opt : Option<IFutureBase> = this.pending_jobs.dequeue();
                if (job_opt.is_some()) {
                    let job : mut IFutureBase = job_opt.some;
                    let result: bool = job.start();
                    let state : RoutineState = job.routine_state();
                    if (!result) {
                        // job is in invalid state, skip it for now
                        println("Scheduler: job in '" + (state as string) + "' state, failed to run");
                    }
                    else {
                        if (state is RoutineState.pending) {
                            this.pending_jobs.enqueue(job);
                        }
                    }
                } else {
                    break;
                }
            }
        }

        fun current() -> Scheduler {
            return _main_scheduler;
        }
    }

    let _main_scheduler : mut Scheduler = new Scheduler();

    interface IGenerator<T> {
        impl IIterator<T>;
    }

    class RoutineContext<T> {
        __impl: __ExternImpl = new __ExternImpl();
        result: mut Option<T> = new Option<T>.none();
        target: mut async_fun<T>;

        fun new(mut this, target: mut async_fun<T>) {
            this.target = target;
        }
        extern fun call(mut this) -> i64;
    }

    class _DefaultRoutine<T> {
        state: mut AtomicI64 = new AtomicI64(0);
        context: mut RoutineContext<T>;

        fun new(mut this, target: async_fun<T>, scheduleNow: bool) {
            this.context = new RoutineContext<T>(target);
            if (scheduleNow) {
                _main_scheduler.pending_jobs.enqueue(this as IFutureBase);
            }
        }

        impl IFutureBase {
            fun routine_state(this: IFutureBase) -> RoutineState {
                let self: Self = this as Self;
                return RoutineState.from_atomic(self.state);
            }

            fun switch_state(this: mut IFutureBase, from: RoutineState, to: RoutineState) -> bool {
                let self: mut Self = this as mut Self;
                return RoutineState.switch(self.state, from, to);
            }

            fun start(this: mut IFutureBase) -> bool {
                let self: mut Self = this as mut Self;
                let res : bool = RoutineState.switch(self.state, new RoutineState.pending(), new RoutineState.running());
                if (!res) 
                    return false;
                __signal 0;
                let return_state : i64 = self.context.call();

                // Blocked = 0, YieldNotFinished = 2, Finished = 3, YieldFinished = 4
                RoutineState.switch(self.state, new RoutineState.running(), RoutineState.from_i64(return_state));

                return true;
            }
        }

        impl IFuture<T> {
            fun poll(this: IFuture<T>) -> mut FutureState<T> {
                let self: Self = this as Self;
                let state_val: i64 = self.state.load();
                
                if (state_val == 2) {
                    return new FutureState<T>.ready(self.context.result.some);
                } else if (state_val == 3) {
                    return new FutureState<T>.finished();
                } else if (state_val == 4) {
                    return new FutureState<T>.ready_finished(self.context.result.some);
                } else {
                    return new FutureState<T>.not_ready();
                }
            }
        }
    
        impl IGenerator<T>;
        impl IIterator<T> {
            fun next(this: mut IIterator<T>) -> Option<T> {
                let self: mut Self = this as mut Self;
                return self.do_wait_any();
            }
        }
    }

    class Event<T> {
        receivers : mut List<IEventReceiver<T>> = new List<IEventReceiver<T>>();

        impl IObjectID;

        fun notify(this, ev: T) {
            for (let receiver : mut IEventReceiver<T> in this.receivers.iter()) {
                 receiver.notify(ev);
            }
            wait;
        }

        fun add_receiver(mut this, receiver: IEventReceiver<T>) {
            for (let r : IEventReceiver<T> in this.receivers.iter()) {
                if (r.equals(receiver))
                    return;
            }
            this.receivers.push(receiver);
        }

        fun remove_receiver(mut this, receiver: IEventReceiver<T>) {
            for (let i : u64 in range(0, this.receivers.size())) {
                let r : Option<IEventReceiver<T>> = this.receivers.at(i);
                if (r.is_some()) {
                    if (r.some.equals(receiver)) {
                        this.receivers.remove(i);
                        return;
                    }
                }
            }
        }
    }

    interface IEventReceiver<T> {
        ev : mut Event<T>;

        fun notify(mut this, ev: T);

        fun connect(mut this, ev: mut Event<T>) {
            this.ev.remove_receiver(this);
            ev.add_receiver(this);
            this.ev = ev;
        }

        impl IObjectID;
    }

    class _AsyncEventReceiver<T> {
        f : mut async_fun<void, T>;

        fun new(mut this, ev: mut Event<T>, f: mut async_fun<void, T>) {
            ev.add_receiver(this);
            (this as  IEventReceiver<T>).ev = ev;
            this.f = f;
        }

        impl IEventReceiver<T> {
            fun notify(this: mut IEventReceiver<T>, ev: T) {
                let self: mut Self = this as mut Self;
                self.f(ev);
            }
        }
    }

    class _QueuedEventReceiver<T> {
        event_queue : mut Queue<T> = new Queue<T>();

        fun new(mut this, ev: mut Event<T>) {
            ev.add_receiver(this);
            (this as IEventReceiver<T>).ev = ev;
        }

        impl IEventReceiver<T> { 
            fun notify(this: mut IEventReceiver<T>, ev: T) {
                let self: mut Self = this as mut Self;
                self.event_queue.enqueue(ev);
            }
        }

        impl IFuture<T> {
            fun poll(this: IFuture<T>) -> mut FutureState<T> {
                let self: Self = this as Self;
                
                let v : Option<T> = self.event_queue.dequeue();
                if (v.is_some()) {
                     return new FutureState<T>.ready(v.some);
                }
                else {
                    return new FutureState<T>.not_ready();
                }
            }
        }
    }

    class _OnetimeEventReceiver<T> {
        value : mut Option<T> = new Option<T>.none();

        fun new(mut this, ev: mut Event<T>) {
            ev.add_receiver(this);
            (this as IEventReceiver<T>).ev = ev;
        }

        impl IEventReceiver<T> { 
            fun notify(this: mut IEventReceiver<T>, v: T) {
                let self: mut Self = this as mut Self;
                self.value = new Option<T>.some(v);
            }
        }

        impl IFuture<T> {
            fun poll(this: IFuture<T>) -> mut FutureState<T> {
                let self: Self = this as Self;
                
                if (self.value.is_some()) {
                     return new FutureState<T>.ready_finished(self.value.some);
                }
                else {
                    return new FutureState<T>.not_ready();
                }
            }
        }
    }

}