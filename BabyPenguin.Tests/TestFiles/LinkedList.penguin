namespace ll {
    class LinkedList <T> {
        head: LinkedListNode<T>;
        tail: LinkedListNode<T>;
        size: i32 = 0;

        fun add(this: mut LinkedList<T>, v: T) {
            if (this.size == 0) {
               this.head = new LinkedListNode<T>();
               this.head.value = v;
               this.head.link = new LinkedListLink<T>.end();
               this.tail = this.head;
            } else {
               let newNode : mut LinkedListNode<T> = new LinkedListNode<T>();
               newNode.value = v;
               newNode.link = new LinkedListLink<T>.end();
               this.tail.link = new LinkedListLink<T>.next(newNode);
               this.tail = newNode;
            }
            this.size += 1;
        }

        fun print_all(this: LinkedList<T>) {
            if (this.size > 0) {
                let current : mut LinkedListNode<T> = this.head;
                while (true) {
                    print(current.value);
                    if (current.link is LinkedListLink<T>.end) {
                        break;
                    } else {
                        current = current.link.next;
                        print(",");
                    }
                }
            }
        }
    }

    enum LinkedListLink <T> {
        end;
        next: auto LinkedListNode<T>;
    }

    class LinkedListNode <T> {
        value: auto T;
        link: mut LinkedListLink<T> = new LinkedListLink<T>.end();
    }

    initial {
        let ll : mut LinkedList<i32> = new LinkedList<i32>();
        ll.add(1);
        ll.add(2);
        ll.add(3);
        ll.print_all();
    }
}